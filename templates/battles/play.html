{% extends 'base.html' %}

{% block title %}Jang - {{ battle }} - Typing Trainer{% endblock %}

{% block extra_css %}
{% if battle.mode == 'code' %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
{% endif %}
<style>
    .word { margin-right: 0.5rem; }
    .correct { color: #292929; }
    .incorrect { background-color: #fee2e2; color: #dc2626; }
    .current { background-color: rgba(41, 41, 41, 0.1); border-left: 3px solid #292929; padding-left: 2px; }
    .typed { color: #6b7280; }
    .stats-card {
        background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
        border-radius: 12px;
        padding: 1rem 1.25rem;
        color: #292929;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }
    .stats-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    }
    .stats-card.wpm { background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); }
    .stats-card.accuracy { background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); }
    .stats-card.time { background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); }
    .stats-card.mistakes { background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); }
    #code-display {
        font-family: 'Fira Code', 'Courier New', monospace;
        font-size: 15px;
        line-height: 1.6;
    }
    .code-line {
        padding: 2px 0;
        min-height: 1.6em;
    }
    .code-line.hljs {
        background: transparent !important;
    }
    .opponent-info {
        background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-6xl mx-auto">
    <!-- Battle Info -->
    <div class="bg-white rounded-lg shadow-lg p-4 mb-4">
        <div class="flex items-center justify-between">
            <div>
                <h1 class="text-2xl font-bold text-primary">{{ battle.creator.username }} vs {{ battle.opponent.username }}</h1>
                <p class="text-sm text-primary">
                    {% if battle.mode == 'text' %}üìù Matn{% else %}üíª Kod{% endif %}
                </p>
            </div>
            <div id="opponent-status" class="opponent-info">
                <p class="text-sm font-semibold text-primary">Raqib holati:</p>
                <p class="text-lg font-bold text-primary" id="opponent-finished">Kutmoqda...</p>
            </div>
        </div>
    </div>

    <!-- Stats Cards -->
    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
        <div class="stats-card wpm">
            <p class="text-sm font-medium text-primary opacity-90 mb-1">{% if battle.mode == 'text' %}WPM{% else %}Code WPM{% endif %}</p>
            <p class="text-3xl font-bold text-primary" id="wpm">0</p>
        </div>
        <div class="stats-card accuracy">
            <p class="text-sm font-medium text-primary opacity-90 mb-1">Aniqlik</p>
            <p class="text-3xl font-bold text-primary" id="accuracy">100%</p>
        </div>
        <div class="stats-card time">
            <p class="text-sm font-medium text-primary opacity-90 mb-1">Vaqt</p>
            <p class="text-3xl font-bold text-primary" id="timer">0s</p>
        </div>
        <div class="stats-card mistakes">
            <p class="text-sm font-medium text-primary opacity-90 mb-1">Xatolar</p>
            <p class="text-3xl font-bold text-primary" id="mistakes-count">0</p>
        </div>
    </div>

    <!-- Main Content -->
    <div class="bg-white rounded-lg shadow-lg p-6">
        {% if battle.mode == 'text' %}
        <!-- Text Battle -->
        <div class="mb-4">
            <h3 class="text-lg font-semibold mb-2 text-primary">{{ battle.text.title }}</h3>
            <div id="text-display" class="text-2xl leading-relaxed p-8 bg-gray-50 rounded-lg border-2 border-gray-200 mb-6 font-mono text-primary">
            </div>
        </div>
        {% else %}
        <!-- Code Battle -->
        <div class="mb-4">
            <h3 class="text-lg font-semibold mb-2 text-primary">{{ battle.code_snippet.title }}</h3>
            <div id="code-display" class="p-6 bg-gray-50 text-primary rounded-lg border-2 border-gray-300 mb-6 overflow-auto">
                <pre><code class="language-{{ battle.code_snippet.language }}">{{ battle.code_snippet.code_body }}</code></pre>
            </div>
        </div>
        {% endif %}
        
        <textarea 
            id="typing-input" 
            class="w-full p-6 bg-gray-50 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-primary focus:ring-2 focus:ring-primary text-xl font-mono text-primary placeholder-gray-400 transition-all duration-300"
            rows="{% if battle.mode == 'text' %}5{% else %}12{% endif %}"
            placeholder="Bu yerga yozishni boshlang..."
            autofocus
            spellcheck="false"
        ></textarea>
        
        <div class="mt-4 flex justify-center">
            <button id="finish-btn" class="flex items-center space-x-2 gradient-secondary text-primary px-6 py-2 rounded-lg font-semibold transition-all duration-300 hover:scale-105 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                <span>Tugatish</span>
            </button>
        </div>
    </div>
    
    <!-- Results -->
    <div id="results" class="hidden mt-6 bg-white rounded-lg shadow-lg p-6 animate-fadeIn">
        <h3 class="text-2xl font-bold text-primary mb-4">Sizning natijangiz</h3>
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
            <div class="text-center p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                <p class="text-sm font-semibold text-primary mb-1">{% if battle.mode == 'text' %}WPM{% else %}Code WPM{% endif %}</p>
                <p class="text-3xl font-bold text-primary" id="result-wpm">0</p>
            </div>
            <div class="text-center p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                <p class="text-sm font-semibold text-primary mb-1">Aniqlik</p>
                <p class="text-3xl font-bold text-primary" id="result-accuracy">0%</p>
            </div>
            <div class="text-center p-4 bg-red-50 rounded-lg border-2 border-red-200">
                <p class="text-sm font-semibold text-red-700 mb-1">Xatolar</p>
                <p class="text-3xl font-bold text-red-600" id="result-mistakes">0</p>
            </div>
            <div class="text-center p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                <p class="text-sm font-semibold text-primary mb-1">Vaqt</p>
                <p class="text-3xl font-bold text-primary" id="result-time">0s</p>
            </div>
        </div>
        <div class="text-center">
            <a href="{% url 'battles:detail' battle.id %}" class="inline-flex items-center space-x-2 gradient-secondary text-primary px-6 py-2 rounded-lg font-semibold transition-all duration-300 hover:scale-105 shadow-lg">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"></path>
                </svg>
                <span>Jang natijalarini ko'rish</span>
            </a>
        </div>
    </div>
</div>

<script>
{% if battle.mode == 'text' %}
const originalText = `{{ battle.text.body|escapejs }}`;
{% else %}
const originalCode = `{{ battle.code_snippet.code_body|escapejs }}`;
const codeLanguage = '{{ battle.code_snippet.language }}';
{% endif %}
const battleId = {{ battle.id }};
let startTime = null;
let timerInterval = null;
let isFinished = false;
let mistakesList = [];
let opponentCheckInterval = null;

const typingInput = document.getElementById('typing-input');
const finishBtn = document.getElementById('finish-btn');
const resultsDiv = document.getElementById('results');
{% if battle.mode == 'text' %}
const textDisplay = document.getElementById('text-display');
{% else %}
const codeDisplay = document.getElementById('code-display');
{% endif %}

let lastTypedLength = 0;

{% if battle.mode == 'text' %}
function initTextDisplay() {
    const words = originalText.trim().split(/\s+/);
    textDisplay.innerHTML = words.map((word, i) => 
        `<span class="word" data-index="${i}">${word}</span>`
    ).join(' ');
    lastTypedLength = 0;
}
{% else %}
function initCodeDisplay() {
    if (typeof hljs !== 'undefined') {
        hljs.highlightAll();
    }
    lastTypedLength = 0;
}
{% endif %}

// Prevent copy-paste
typingInput.addEventListener('paste', (e) => {
    e.preventDefault();
    return false;
});

typingInput.addEventListener('copy', (e) => {
    e.preventDefault();
    return false;
});

typingInput.addEventListener('cut', (e) => {
    e.preventDefault();
    return false;
});

// Check opponent status periodically
function checkOpponentStatus() {
    fetch(`{% url 'battles:detail' battle.id %}`, {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
        }
    })
    .then(response => response.text())
    .then(html => {
        // Parse opponent status from response (simplified - in production use API)
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        // This is a simplified check - you might want to create a dedicated API endpoint
    })
    .catch(err => console.error('Error checking opponent:', err));
}

// Start checking opponent status
opponentCheckInterval = setInterval(checkOpponentStatus, 3000); // Check every 3 seconds

typingInput.addEventListener('input', (e) => {
    const currentValue = typingInput.value;
    const currentLength = currentValue.length;
    const previousLength = lastTypedLength;
    
    // Detect paste
    if (currentLength - previousLength > 1) {
        typingInput.value = currentValue.substring(0, previousLength);
        return;
    }
    
    lastTypedLength = typingInput.value.length;
    startTyping();
    updateDisplay();
});

{% if battle.mode == 'text' %}
function updateDisplay() {
    const typed = typingInput.value;
    const words = originalText.trim().split(/\s+/);
    const typedWords = typed.trim().split(/\s+/);
    
    let html = '';
    let mistakes = 0;
    mistakesList = [];
    
    words.forEach((word, i) => {
        const typedWord = typedWords[i] || '';
        let classes = 'word';
        
        if (i < typedWords.length - 1) {
            if (word === typedWord) {
                classes += ' correct typed';
            } else {
                classes += ' incorrect typed';
                mistakes++;
            }
        } else if (i === typedWords.length - 1) {
            classes += ' current';
            if (typedWord.length > 0 && !word.startsWith(typedWord)) {
                classes += ' incorrect';
                mistakes++;
            }
        }
        
        html += `<span class="${classes}" data-index="${i}">${word}</span> `;
    });
    
    textDisplay.innerHTML = html;
    
    if (startTime) {
        const elapsed = (Date.now() - startTime) / 1000;
        const typedChars = typed.length;
        const correctChars = typedChars - mistakes;
        const wpm = (typedWords.length / elapsed) * 60;
        const accuracy = typedChars > 0 ? ((correctChars / typedChars) * 100) : 100;
        
        document.getElementById('wpm').textContent = Math.round(wpm);
        document.getElementById('accuracy').textContent = Math.round(accuracy) + '%';
        document.getElementById('timer').textContent = Math.round(elapsed) + 's';
        document.getElementById('mistakes-count').textContent = mistakes;
        
        if (typedWords.length >= words.length && typed.trim().length >= originalText.trim().length) {
            finishTyping(wpm, accuracy, mistakes, elapsed);
        }
    }
}
{% else %}
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function updateDisplay() {
    const typed = typingInput.value;
    const originalLines = originalCode.split('\n');
    const typedLines = typed.split('\n');
    
    let html = '';
    let mistakes = 0;
    mistakesList = [];
    
    originalLines.forEach((line, lineIdx) => {
        const typedLine = typedLines[lineIdx] || '';
        let lineHtml = '<div class="code-line">';
        
        if (lineIdx < typedLines.length - 1) {
            if (line === typedLine) {
                lineHtml += '<span class="correct typed">' + escapeHtml(line) + '</span>';
            } else {
                lineHtml += '<span class="incorrect typed">' + escapeHtml(line) + '</span>';
                mistakes++;
                mistakesList.push({ line: lineIdx + 1, original: line, typed: typedLine });
            }
        } else if (lineIdx === typedLines.length - 1) {
            for (let i = 0; i < line.length; i++) {
                const typedChar = typedLine[i] || '';
                const originalChar = line[i];
                
                if (i < typedLine.length) {
                    if (originalChar === typedChar) {
                        lineHtml += '<span class="correct typed">' + escapeHtml(originalChar) + '</span>';
                    } else {
                        lineHtml += '<span class="incorrect">' + escapeHtml(originalChar) + '</span>';
                        mistakes++;
                    }
                } else if (i === typedLine.length) {
                    lineHtml += '<span class="current">' + escapeHtml(originalChar) + '</span>';
                } else {
                    lineHtml += '<span>' + escapeHtml(originalChar) + '</span>';
                }
            }
        } else {
            if (typeof hljs !== 'undefined') {
                const highlighted = hljs.highlight(line, { language: codeLanguage });
                lineHtml += highlighted.value;
            } else {
                lineHtml += escapeHtml(line);
            }
        }
        
        lineHtml += '</div>';
        html += lineHtml;
    });
    
    codeDisplay.querySelector('pre code').innerHTML = html;
    if (typeof hljs !== 'undefined') {
        hljs.highlightAll();
    }
    
    if (startTime) {
        const elapsed = (Date.now() - startTime) / 1000;
        const typedChars = typed.length;
        const correctChars = typedChars - mistakes;
        const wpm = (typedChars / 5 / elapsed) * 60;
        const accuracy = typedChars > 0 ? ((correctChars / typedChars) * 100) : 100;
        
        document.getElementById('wpm').textContent = Math.round(wpm);
        document.getElementById('accuracy').textContent = Math.round(accuracy) + '%';
        document.getElementById('timer').textContent = Math.round(elapsed) + 's';
        document.getElementById('mistakes-count').textContent = mistakes;
        
        if (typed.trim() === originalCode.trim()) {
            finishTyping(wpm, accuracy, mistakes, elapsed);
        }
    }
}
{% endif %}

function startTyping() {
    if (!startTime) {
        startTime = Date.now();
        timerInterval = setInterval(updateDisplay, 100);
        finishBtn.disabled = false;
    }
}

function finishTyping(wpm, accuracy, mistakes, duration) {
    if (isFinished) return;
    isFinished = true;
    
    clearInterval(timerInterval);
    if (opponentCheckInterval) {
        clearInterval(opponentCheckInterval);
    }
    typingInput.disabled = true;
    finishBtn.disabled = true;
    
    document.getElementById('result-wpm').textContent = Math.round(wpm);
    document.getElementById('result-accuracy').textContent = Math.round(accuracy) + '%';
    document.getElementById('result-mistakes').textContent = mistakes;
    document.getElementById('result-time').textContent = Math.round(duration) + 's';
    resultsDiv.classList.remove('hidden');
    
    // Save result to battle
    fetch('{% url "battles:save_result" battle.id %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify({
            wpm: wpm,
            accuracy: accuracy,
            mistakes: mistakes,
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Check if battle is finished
            if (data.battle_finished) {
                document.getElementById('opponent-finished').textContent = 'Jang tugadi!';
            } else {
                document.getElementById('opponent-finished').textContent = 'Raqib tugatishni kutmoqda...';
            }
        }
    })
    .catch(err => console.error('Error saving result:', err));
}

finishBtn.addEventListener('click', () => {
    const typed = typingInput.value;
    const elapsed = (Date.now() - startTime) / 1000;
    {% if battle.mode == 'text' %}
    const words = originalText.trim().split(/\s+/);
    const typedWords = typed.trim().split(/\s+/);
    const typedChars = typed.length;
    const mistakes = mistakesList.length;
    const correctChars = typedChars - mistakes;
    const wpm = (typedWords.length / elapsed) * 60;
    const accuracy = typedChars > 0 ? ((correctChars / typedChars) * 100) : 100;
    {% else %}
    const typedChars = typed.length;
    const mistakes = mistakesList.length;
    const correctChars = typedChars - mistakes;
    const wpm = (typedChars / 5 / elapsed) * 60;
    const accuracy = typedChars > 0 ? ((correctChars / typedChars) * 100) : 100;
    {% endif %}
    finishTyping(wpm, accuracy, mistakes, elapsed);
});

{% if battle.mode == 'text' %}
initTextDisplay();
{% else %}
initCodeDisplay();
{% endif %}
</script>
{% endblock %}

